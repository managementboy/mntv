Index: video.py
===================================================================
--- video.py	(revision 249)
+++ video.py	(working copy)
@@ -9,6 +9,7 @@
 import os
 import re
 import sys
+import database
 
 from stat import *
 
@@ -88,34 +89,48 @@
   def NeedsTranscode(self, out=sys.stdout):
     """NeedsTranscode -- decide if a video needs transcoding before import"""
 
+    #Instead of going clunky and building our own hash of good and not good codecs, it
+    # would be easier to grab the information directly from myths own videotypes table 
+    db = database.MythNetTvDatabase()
+    row = db.GetOneRow("select playcommand from videotypes where extension = '"+self.values['ID_VIDEO_FORMAT']+"'")
+    if row:
+        if row['playcommand'] == 'Internal':
+            out.write('Files in format %s don\'t need transcoding\n' % self.values['ID_VIDEO_FORMAT'])
+            return False
+        else:
+            return True
+    else:
+        out.write('Your file format does not appear in our db, so we\'re going to transcode anyway\n')
+        return True
+     
     # Doesn't need transcoding
-    return_false = ['mp4v', '0x10000002', 'divx', 'DIVX', 'XVID',
-                    'DX50']
+    #return_false = ['mp4v', '0x10000002', 'divx', 'DIVX', 'XVID',
+    #                'DX50']
 
     # Does need transcoding
     # Note that some avc1 videos work, and some don't -- so all get transcoded
-    return_true = ['avc1', 'theo', 'WMV2', 'FLV1']
+    #return_true = ['avc1', 'theo', 'WMV2', 'FLV1']
 
-    if self.values['ID_VIDEO_FORMAT'] in return_false:
-      out.write('Files in format %s don\'t need transcoding\n'
-                % self.values['ID_VIDEO_FORMAT'])
-      return False
+    #if self.values['ID_VIDEO_FORMAT'] in return_false:
+    #  out.write('Files in format %s don\'t need transcoding\n'
+    #            % self.values['ID_VIDEO_FORMAT'])
+    #  return False
 
-    if self.values['ID_VIDEO_FORMAT'] in return_true:
-      out.write('Files in format %s do need transcoding\n'
-                % self.values['ID_VIDEO_FORMAT'])
-      return True
+    #if self.values['ID_VIDEO_FORMAT'] in return_true:
+    #  out.write('Files in format %s do need transcoding\n'
+    #            % self.values['ID_VIDEO_FORMAT'])
+    #  return True
 
-    else:
-      out.write("""
-****************************************************************
-I don't know if we need to transcode videos in %s format
-I'm going to give it a go without, and it if doesn't work
-please report it to mikal@stillhq.com
-****************************************************************
-"""
-                % self.values['ID_VIDEO_FORMAT'])
-      return False
+    #else:
+     # out.write("""
+#****************************************************************
+#I don't know if we need to transcode videos in %s format
+#I'm going to give it a go without, and it if doesn't work
+#please report it to mikal@stillhq.com
+#****************************************************************
+#"""
+#                % self.values['ID_VIDEO_FORMAT'])
+ #     return False
 
   def NewFilename(self, datadir, extn, out=sys.stdout):
     """NewFilename -- determine what filename to use after transcoding"""
Index: mythnettv
===================================================================
--- mythnettv	(revision 249)
+++ mythnettv	(working copy)
@@ -256,9 +256,14 @@
     # Go and grab the XML file from the remote HTTP server, and then parse it
     # as an RSS feed with enclosures. Populates a TODO list in 
     # mythnettv_programs
-    proxy = proxyhandler.HttpHandler(db)
-    xmlfile = proxy.Open(argv[2], out=out)
-    syndication.Sync(db, xmlfile, argv[3], out=out)
+    
+    #check to see if the correct number of args has been passed
+    if len(argv) == 4:
+        proxy = proxyhandler.HttpHandler(db)
+        xmlfile = proxy.Open(argv[2], out=out)
+        syndication.Sync(db, xmlfile, argv[3], out=out)
+    else:
+        out.write("Not enough arguments, please ensure you specify all values\n")
 
   elif argv[1] == 'file':
     # Treat the local file as an RSS feed. Populates a TODO list in
