#!/usr/bin/python

# Copyright (C) Michael Still (mikal@stillhq.com) 2006, 2007, 2008, 2009
# Released under the terms of the GNU GPL v2

# Import the client module
from deluge.ui.client import client
from twisted.internet import reactor
from deluge.ui.console.main import BaseCommand
import deluge.ui.console.colors as colors
import deluge.component as component
import commands
import datetime
import gflags
import os
import subprocess
import sys
import tempfile
import base64
import time


FLAGS = gflags.FLAGS
gflags.DEFINE_string('uploadrate', '',
                     'Override the default upload rate for bittorrent for '
                     'just this one download')


class BitTorrentDownloadException(Exception):
  """Raised when download fails."""
  pass


def Download(torrent_filename, tmpname, info_func,
             upload_rate=1000000, verbose=False, out=sys.stdout):
  """Download a bittorrent

  Args:
     torrent_filename: (string)   path to the .torrent file
     tmpname:          (string)   where to put download
     info_func:        (function) called every now and then with status
     upload_rate:      (int)      limit the upload speed
     verbose:          (boolean)  dump a bunch of debug info as well
  """

  out.write('Now fetching the bittorrent data\n')
  download_ok = False
  
  opts = {}
  opts['payload_upload_rate'] = str(upload_rate)
  opts['completed_path'] = str(tmpname)
  opts['completed'] = 'true'
  
#  try:
#    cmd = '/usr/bin/btdownloadheadless.bittornado ' \
#          '--max_upload_rate %s ' \
#          '--display_interval 5 --spew 1 --saveas %s %s ' \
#          %(upload_rate, tmpname, torrent_filename)
#    po = subprocess.Popen(cmd, shell=True, bufsize=1,
#                          stdout=subprocess.PIPE,
#                          stderr=subprocess.STDOUT)
#    out.write('Executing: %s (pid %d)\n' %(cmd, po.pid))
  
  d = client.connect(host='127.0.0.1', port=58846, username='deluge', password='deluge')

  # We create a callback function to be called upon a successful connection
  #
  def on_connect_success(result):
    out.write('Connection was successful!')
    filedump = base64.encodestring(open(torrent_filename).read())
    torrentname = 'download.torrent'
    
    def on_add_torrent_file(value, key):
      print "Sent torrent value to the daemon!"
      print "%s: %s\n" % (key, value)

    client.core.add_torrent_file(torrentname, filedump, opts).addCallback(on_add_torrent_file, "file added")
    
    def on_monitor_torrent(value, key):
      print "%s: %s" % (key, value)

    eta = 0
    print "%s" % (eta)
    while eta <> -1:
      print "%s" % (eta)
      eta = client.core.torrent.eta().addCallback(on_monitor_torrent, "Monitoring:")
      time.sleep(5)

    client.disconnect()
    reactor.stop()
   
  #d.addCallback(on_connect_success).addCallback(on_add_torrent_file, "file added")

  def on_connect_fail(result):
    out.write('Connection failed!')
    out.write('result:', result)

  # We add the callback (in this case it's an errback, for error)
  d.addErrback(on_connect_fail)

#  client.core.get_config_value("download_location").addCallback(on_get_config_value, "download_location")
#  client.core.add_torrent_file(torrentname, filedump, opts).addCallback(on_success).addErrback(on_fail)
  reactor.run()

#  delugetorrent = client.core.add_torrent_file(torrentname, filedump, opts)
#  out.write(delugetorrent)
#  except:
#    pass

  d = client.connect(host='127.0.0.1', port=58846, username='deluge', password='deluge')

  # We create a callback function to be called upon a successful connection
  #
  def on_connect_success(result):
    out.write('Connection was successful!')
    filedump = base64.encodestring(open(torrent_filename).read())
    torrentname = 'download.torrent'

    def on_monitor_torrent(value, key):
      print "%s: %s" % (key, value)

    eta = 0
    print "%s" % (eta)
    while eta <> -1:
      print "%s" % (eta)
      eta = client.core.torrent.eta().addCallback(on_monitor_torrent, "Monitoring:")
      time.sleep(5)

    client.disconnect()
    reactor.stop()
